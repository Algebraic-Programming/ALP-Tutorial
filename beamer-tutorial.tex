\documentclass[aspectratio=169]{beamer}
\usetheme{Madrid}
\usecolortheme{seahorse}
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{footline}[frame number]

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{amsmath,amssymb,mathtools}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{listings}

\newcommand{\PA}[1]{{\textcolor{cyan}{[{\bfseries PA:} #1]}}}
\newcommand{\DeJ}[1]{{\textcolor{magenta}{[{\bfseries DJ:} #1]}}} % DJ was taken!
\newcommand{\AJ}[1]{{\textcolor{green}{[{\bfseries AJ:} #1]}}}
\newcommand{\GG}[1]{{\textcolor{blue}{[{\bfseries GG:} #1]}}}

% Map common Unicode symbols to LaTeX math (outside listings)
\usepackage{newunicodechar}
\newunicodechar{·}{\ensuremath{\cdot}}
\newunicodechar{⊙}{\ensuremath{\odot}}
\newunicodechar{ᵀ}{\ensuremath{^{\top}}}
\newunicodechar{×}{\ensuremath{\times}}
\newunicodechar{–}{-}
\newunicodechar{—}{-}

% Listing styles (Unicode-safe for later use)
\definecolor{terminalback}{rgb}{0.1,0.1,0.1}
\definecolor{terminaltext}{rgb}{0.9,0.9,0.9}
\lstdefinestyle{terminal}{
    backgroundcolor=\color{terminalback},
    basicstyle=\ttfamily\small\color{terminaltext},
    frame=single, rulecolor=\color{white}, breaklines=true,
    captionpos=b, showstringspaces=false,
    upquote=true, columns=fullflexible,
    literate={·}{{$\cdot$}}1 {⊙}{{$\odot$}}1 {ᵀ}{{$^\top$}}1 {×}{{$\times$}}1 {‐}{{-}}1 {–}{{-}}1 {—}{{-}}1
}
\lstdefinestyle{code}{
    backgroundcolor=\color[rgb]{0.95,0.95,0.95},
    basicstyle=\ttfamily\small, frame=single, breaklines=true,
    rulecolor=\color{black}, numbers=none, keepspaces=true, captionpos=b, tabsize=2,
    language=C++,
    literate={·}{{$\cdot$}}1 {⊙}{{$\odot$}}1 {ᵀ}{{$^\top$}}1 {×}{{$\times$}}1 {‐}{{-}}1 {“}{{"`}}1 {”}{{'"}}1
}

\title{Algebraic Programming (ALP) Tutorial}
\subtitle{From HPC to GraphBLAS and Transition Paths}
\author{ALP Team}
\date{\today}

% Show roadmap before each section/subsection with upcoming content highlighted
\AtBeginSection{
  \begin{frame}{Roadmap}
    \tableofcontents[currentsection,sectionstyle=show/shaded,subsectionstyle=show/show/hide]
  \end{frame}
}
\AtBeginSubsection{
  \begin{frame}{Roadmap}
    \tableofcontents[currentsection,currentsubsection,sectionstyle=show/shaded,subsectionstyle=show/shaded/hide]
  \end{frame}
}

\begin{document}
\frame{\titlepage}

% =========================
% Monday 10 Nov
% =========================
\section{Monday 10 Nov}

% One initial agenda slide for Monday; will be auto-repeated via Roadmap frames
\begin{frame}{Today's Plan (Monday)}
\begin{enumerate}
  \item Introduction to GraphBLAS and ALP
  \item Installation on Linux, demos
  \item Hands-on: containers, I/O, copying, masking, standard matrices
  \item Introduction to primitives
  \item Exercise 8
  \item Closure: transition paths, Python mxv examples
  \item Ising Machine, new solvers
\end{enumerate}
\end{frame}

\subsection{1) Introduction to GraphBLAS and ALP}
% Owner: DJ

% Intro (concise outline)
\begin{frame}{Introduction to GraphBLAS and ALP}
\begin{itemize}
  \item What you'll learn: algebraic programming for graphs and sparse data
  \item Who it's for: HPC developers and solver authors
  \item How we'll use ALP: C++ headers, precompiled libraries, Python API
\end{itemize}
% Owner: DJ
% TODO: add a one-slide agenda summary graphic
\end{frame}

% Slide 1
\begin{frame}{Goals, Audience, and Scope}
\begin{itemize}
  \item Goals
    \begin{itemize}
      \item Express algorithms as algebra over vectors/matrices
      \item Introduce GraphBLAS: containers, semirings, primitives, masks
      \item Demonstrate ALP backends for performance portability
    \end{itemize}
  \item Audience
    \begin{itemize}
      \item Developers of HPC applications, graph analytics, and solvers
      \item No prior GraphBLAS/ALP knowledge assumed
    \end{itemize}
  \item Scope: multiple usage modes
    \begin{itemize}
      \item C++ header library for new algorithms/solvers (template API)
      \item Precompiled libraries: use provided algorithms as black boxes
      \item Python API for precompiled algorithms
    \end{itemize}
\end{itemize}
% Owner: DJ
% Source: ALP_Tutorial.tex (intro), alp_graphblas_tutorial.txt (overview)
\end{frame}

% Slide 2
\begin{frame}{ALP in One Slide: Programming Model and Backends}
\begin{itemize}
  \item Programming model (humble by design)
    \begin{itemize}
      \item Heavily templated C++ header library (no runtime codegen)
      \item Hardware-unaware, hardware-independent user code
      \item Algebraic API: write what to compute, not how
    \end{itemize}
  \item Backends handle hardware specifics
    \begin{itemize}
      \item reference (single-threaded), \texttt{reference\_omp} (OpenMP)
      \item nonblocking (multi-threaded with auto-fusion)
      \item bsp1d (distributed/LPF), dense-dispatch (BLAS-backed, WIP), tensor (experimental, WIP)
      \item Same source runs across backends with consistent semantics
    \end{itemize}
  \item Flexible infrastructure
    \begin{itemize}
      \item Rich type system and traits enable different and mixed data-type operations
      \item Compile-time algebraic properties (associative, commutative, idempotent, annihilators)
            are known to the backends and propagate from top to bottom of the algorithm
    \end{itemize}
\end{itemize}
% Owner: DJ
% TODO: add pipeline diagram: User code → algebra → backend → hardware
% Source: ALP_Tutorial.tex (intro), alp_graphblas_tutorial.txt (ALP focus)
\end{frame}

% Slide 3
\begin{frame}{What is GraphBLAS: Concepts and Motivation}
\begin{itemize}
  \item Motivation
    \begin{itemize}
      \item Graphs map to sparse matrices; algorithms to linear algebra
      \item Sparse/graph workloads are bandwidth-bound and irregular
    \end{itemize}
  \item Core concepts
    \begin{itemize}
      \item Semirings $\langle D,\oplus,\otimes\rangle$ (plus–times, min–plus, Boolean)
      \item Primitives: mxv/vxm, mxm, eWiseAdd/Mul/Apply, dot, masks, descriptors
      \item Containers: \texttt{grb::Vector<T>}, \texttt{grb::Matrix<T>}
    \end{itemize}
  \item Why beyond traditional dense LA
    \begin{itemize}
      \item Algebraic flexibility enables BFS, SSSP, etc., via non-standard "addition" and "multiplication"
      \item Masking and sparsity-aware execution preserve efficiency
    \end{itemize}
\end{itemize}
% Owner: DJ
% Source: alp_graphblas_tutorial.txt (GraphBLAS), ALP_Tutorial.tex (ALP/GraphBLAS)
\end{frame}

% Slide 4
\begin{frame}{Automation and Optimization Space}
\begin{itemize}
  \item What automation to expect (from ALP backends)
    \begin{itemize}
      \item Auto-parallel execution (threads/processes) across backends
      \item Cache-aware blocking/tiling; minimized data movement
      \item Mask-aware computation and potential kernel fusion (backend-dependent)
    \end{itemize}
  \item Algorithm-level optimization space (ALP vs. BLAS/LAPACK)
    \begin{itemize}
      \item ALP: end-to-end algebraic programs expose global opportunities
            (fusion across primitives, mask-driven sparsity cuts, reordering, schedule selection)
      \item LAPACK: dense factorizations focus on tiling and blocking inside fixed algorithms
      \item BLAS-only: kernel-local tuning; limited visibility for cross-kernel optimizations
    \end{itemize}
  \item Portability outcome
    \begin{itemize}
      \item Express once at the algebraic level; get optimized code on shared, distributed, or hybrid memory systems
      \item Mixed-type and custom-operator workflows supported via templates
    \end{itemize}
\end{itemize}
% Owner: DJ
% TODO: add a tiny mxv code snippet + "same code, different backend" example timings
% Source: ALP_Tutorial.tex (semantics, portability), alp_graphblas_tutorial.txt (landscape)
\end{frame}

% (Duplicate intro frames removed below to avoid repetition)


\subsection{2) Installation on Linux, demos}
\begin{frame}[fragile]{2.ALP Installation}
\framesubtitle{Prerequisites (skip if already installed)}
\begin{itemize}
    \item Requirements:
    \begin{itemize}
        \item C++11 compiler, OpenMP, CMake (>=3.13), libNUMA, pthreads
    \end{itemize}
    \item Debian/Ubuntu:
\begin{lstlisting}[style=terminal, language=bash]
sudo apt-get install build-essential libnuma-dev libpthread-stubs0-dev cmake
\end{lstlisting}
    \item Red Hat/CentOS:
\begin{lstlisting}[style=terminal, language=bash]
dnf group install "Development Tools"
dnf install numactl-devel cmake
\end{lstlisting}
\end{itemize}
% Owner: PA
% Source (ALP_Tutorial.tex - Installation on Linux, step 1)
\end{frame}

\begin{frame}[fragile]{2. ALP Installation}
\framesubtitle{Obtain and Build ALP}
\begin{enumerate}
    \item Clone \textbf{ALP} from the official GitHub repository:
\begin{lstlisting}[style=terminal, language=bash]
git clone https://github.com/Algebraic-Programming/ALP.git
\end{lstlisting}
    \item Build and install \textbf{ALP} with default configuration settings:
\begin{lstlisting}[style=terminal, language=bash]
cd ALP && mkdir build && cd build
../bootstrap.sh --prefix=../install
make -j
make install
\end{lstlisting}
\end{enumerate}
% Owner: PA
% Source (ALP_Tutorial.tex - Installation on Linux, steps 2-3)
\end{frame}

\begin{frame}[fragile]{2. ALP Installation}
\framesubtitle{Setup Environment and Test}
\begin{enumerate}
    \item \textbf{Activate ALP environment}:
\begin{lstlisting}[style=terminal, language=bash]
source ../install/bin/setenv
\end{lstlisting}
    \item \textbf{Compile example}:
\begin{lstlisting}[style=terminal, language=bash]
grbcxx ../examples/sp.cpp -o sp_example
\end{lstlisting}
    \item \textbf{Run}:
\begin{lstlisting}[style=terminal, language=bash]
grbrun ./sp_example
\end{lstlisting}
\end{enumerate}
% Owner: PA
% Source (ALP_Tutorial.tex - Installation on Linux, steps 4-6)
\end{frame}

\begin{frame}[fragile]{3. Hands-on: Setting up scripts}
    \framesubtitle{ALP/GraphBLAS Overview}
    \begin{itemize}
        \item You can find code skeletons for the tutorial in: \texttt{/some/path/to/alp/tutorial/scripts}
        \item You should copy the scripts to your home directory: 
\begin{lstlisting}[style=terminal, language=bash]
cp -r /some/path/to/alp/tutorial/scripts ~/alp_tutorial_scripts
cd ~/alp_tutorial_scripts && ls -l
\end{lstlisting}
        \item You can use any editor of your preference to edit these scripts (e.g. nano, vim, gedit)
        \item Run these commands to test your setup:
\begin{lstlisting}[style=terminal, language=bash]
grbcxx alp_hw.cpp
grbrun ./a.out
\end{lstlisting}
\item \textbf{Expected output}:
\begin{lstlisting}[style=terminal, language=bash]
Info: grb::init (reference) called.
Hello from ./a.out
Info: grb::finalize (reference) called.
\end{lstlisting}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{3. Hands-on: What did we just run?}
    \framesubtitle{Hello World in ALP/GraphBLAS}
    \vspace{-0.6em}
    \begin{lstlisting}[style=code, language=C++, basicstyle=\ttfamily\scriptsize]
#include <cstddef>
#include <cstring>
#include <graphblas.hpp>
#include <assert.h>

constexpr size_t max_fn_size = 255;
typedef char Filename[ max_fn_size ];

void hello_world( const Filename &in, int &out ) {
    std::cout << "Hello from " << in << std::endl;
    out = 0;
}

int main( int argc, char ** argv ) {
    Filename fn;
    std::strncpy( fn, argv[0], max_fn_size );
    int error_code = 100;
    
    grb::Launcher< grb::AUTOMATIC > launcher;
    launcher.exec( &hello_world, fn, error_code, true );
    return error_code;
}
        \end{lstlisting}
        % Owner: PA
        % Source (ALP_Tutorial.tex - ALP/GraphBLAS, Hello World)
\end{frame}

\begin{frame}{3. Hands-on: What did we just run?}
\framesubtitle{ALP/GraphBLAS Overview \PA{Some of this info might/should be at the intro. Adjust accordingly.}}
\begin{itemize}
    \item Pure C++ (developed similarly to the GraphBLAS C specification)
    \item Exposes a GraphBLAS interface with 3 categories (part of the \texttt{grb} namespace):
    \begin{itemize}
        \item Algebraic containers (vectors, matrices, etc.)
        \item Algebraic structures (binary operators, semirings, etc.)
        \item Algebraic operations (take containers and structures as arguments)
    \end{itemize}
    \item \textbf{\texttt{grb::Launcher}}:
    \begin{itemize}
        \item Wraps calls to ALP programs
        \item Adapts to run-time conditions (e.g., distributed execution)
        \item \textbf{Question:} Why is the last argument to \texttt{launcher.exec} \texttt{true}?
        \begin{itemize}
            \item Consider the programmer reference documentation for the \texttt{grb::Launcher}...
        \end{itemize}
    \end{itemize}
    \item All ALP programs: input (\href{https://www.geeksforgeeks.org/cpp/pod-type-in-cpp/}{\textcolor{blue}{POD}}) $\rightarrow$ output (POD)
    \begin{itemize}
        \item \textbf{\texttt{hello\_world} example}:
        \begin{itemize}
            \item \textbf{Question:} Why is \texttt{argv[0]} not directly passed as input to \texttt{hello\_world}?
            \item Returns zero error\_code as output (POD type)
        \end{itemize}
    \end{itemize}
\end{itemize}
\vfill
\colorbox{gray!20}{
\begin{minipage}{0.95\textwidth}
\small
\textbf{For more info:} ALP Documentation: \url{http://albert-jan.yzelman.net/alp/user/}
\end{minipage}}
% Owner: PA
% Source (ALP_Tutorial.tex - ALP/GraphBLAS, Hello World explanation)
\end{frame}

\subsection{3) Hands-on: containers, I/O, copying, masking, standard matrices (3.1–3.3)}
\begin{frame}[fragile]{3.1. Hands-on: Containers}
\framesubtitle{3.1. ALP/GraphBLAS Containers}
\begin{itemize}
    \item \textbf{Primary containers:} \texttt{grb::Vector<T>} and \texttt{grb::Matrix<T>}
    \begin{itemize}
        \item Templated on value type \texttt{T} (any POD type: \texttt{double}, \texttt{std::complex<T>}, etc.)
        \item Support for sparse: Store nonzeros efficiently internally (with CSR/CSC formats)
    \end{itemize}
    \item \textbf{Examples:}
\begin{lstlisting}[style=code, language=C++, basicstyle=\ttfamily\scriptsize]
grb::Vector<double> x(100000), y(150000);
grb::Matrix<void> A(150000, 100000);
\end{lstlisting}
\begin{itemize}
    \item \textbf{Note:} \texttt{Matrix<void>} stores pattern only (Boolean matrices/unweighted graphs)
\end{itemize}
\item \textbf{Container Properties:}
    \begin{itemize}
        \item \texttt{grb::size(vector)}, \texttt{grb::nrows(matrix)}, \texttt{grb::ncols(matrix)}: dimensions
        \item \texttt{grb::nnz(container)}: number of stored elements ($<<$ nrows $\times$ ncols for sparse matrices)
        \item \texttt{grb::capacity(container)}: maximum capacity (default: max dimension)
    \end{itemize}
    \item \textbf{Basics:} New containers are \textbf{empty}; size is \textbf{fixed}, capacity \textbf{can be increased}
\end{itemize}
% Owner: PA
% Source (ALP_Tutorial.tex - ALP/GraphBLAS Containers)
\end{frame}

\begin{frame}[fragile]{3.1. Hands-on: Containers}
\framesubtitle{Exercise 2}
\vspace{-0.5em}
\textbf{Exercise 2.} Allocate the following vectors and matrices:
\begin{itemize}
    \item \texttt{grb::Vector<double>} \texttt{x}: length 100, capacity 100
    \item \texttt{grb::Vector<double>} \texttt{y}: length 1\ 000, capacity 1\ 000
    \item \texttt{grb::Matrix<double>} \texttt{A}: size $(100 \times 1\ 000)$, capacity 1\ 000
    \item \texttt{grb::Matrix<double>} \texttt{B}: size $(100 \times 1\ 000)$, capacity 5\ 000
    \item Start from \texttt{alp\_hw.cpp} 
\begin{lstlisting}[style=terminal, language=bash, basicstyle=\ttfamily\scriptsize\color{terminaltext}] 
cp alp\_hw.cpp alp\_containers\_ex2.cpp 
\end{lstlisting}
    \item \textbf{Hint:} search the documentation for how to override the default capacities
\end{itemize}
\textbf{Expected output}:
\begin{lstlisting}[style=terminal, language=bash, basicstyle=\ttfamily\scriptsize\color{terminaltext}]
Info: grb::init (reference) called.
Capacity of x: 100
Capacity of y: 1000
Capacity of A: 1000
Capacity of B: 5000
Info: grb::finalize (reference) called.
\end{lstlisting}
\textbf{Question.} Is overriding the default capacity necessary for all of \texttt{x, y, A} and \texttt{B}?
% Owner: PA
% Source (ALP_Tutorial.tex - ALP/GraphBLAS Containers, Exercise 2)
\end{frame}

\begin{frame}[fragile]{3.2. Hands-on: Basic Container I/O}
\framesubtitle{Container primitives and accessing elements}
ALP/GraphBLAS containers use iterators and custom primitives to manipulate data:
\\
\vspace{1em}
\textbf{Basic container manipulation primitives:}
\begin{itemize}
    \item \texttt{grb::clear(container)}: removes all elements
    \item \texttt{grb::set(vector,scalar)}: sets all elements to \textit{scalar} (-> dense)
    \item \texttt{grb::setElement(vector,scalar,index)}: sets element at \textit{index} to \textit{scalar}
\end{itemize}
\vspace{1em}
\textbf{C++ STL-compatible iterators:}
\begin{lstlisting}[style=code, language=C++, basicstyle=\ttfamily\scriptsize]
for( const auto &pair : y ) {
    std::cout << "y[" << pair.first << "]=" << pair.second << "\n";
}
\end{lstlisting}
% Owner: PA
% Source (ALP_Tutorial.tex - Basic Container I/O)
\end{frame}

\begin{frame}[fragile]{3.2. Hands-on: Basic Container I/O}
    \framesubtitle{Exercise 3: Container manipulation}
    \textbf{Exercise 3.} Allocate:
    \begin{itemize}
        \item \texttt{grb::Vector<bool>} \texttt{x}, \texttt{y}: length 497, capacities 497 and 1
        \item \texttt{grb::Matrix<void>} \texttt{A}: size $497 \times 497$, capacity 1727
        \item Initialize \texttt{y} with \texttt{true} at index 200
        \item Initialize \texttt{x} with \texttt{false} everywhere
        \item Print nnz for \texttt{x} and \texttt{y}
    \end{itemize}
    Start from \texttt{alp\_containers\_ex2.cpp} 
\begin{lstlisting}[style=terminal, language=bash, basicstyle=\ttfamily\scriptsize\color{terminaltext}] 
cp alp\_containers\_ex2.cpp alp\_containers\_ex2.cpp 
\end{lstlisting}
    \textbf{Expected output:}
    \begin{lstlisting}[style=terminal, language=bash, basicstyle=\ttfamily\scriptsize\color{terminaltext}]
    nonzeroes in x: 497
    nonzeroes in y: 1
    \end{lstlisting}
    \textbf{Bonus question:} Print the capacity of \texttt{y}. Should the value returned be unexpected, considering the specification in the user documentation, is this a bug in ALP?
% Owner: PA
% Source (ALP_Tutorial.tex - Basic Container I/O, Exercise 3)
\end{frame}


\begin{frame}[fragile]{3.2. Hands-on: Basic Container I/O}
    \framesubtitle{Exercise 4: Itterators}
    \textbf{Exercise 4.} Use output iterators to double-check that \texttt{x} has $497$ values and that all those values equal \texttt{false}:
    \begin{itemize}
        \item Use STL-compatible iterators to iterate over \texttt{x}
        \item Count the number of entries and verify each value is \texttt{false}
    \end{itemize}
    Start from \texttt{alp\_containers\_ex3.cpp}
    \begin{lstlisting}[style=terminal, language=bash, basicstyle=\ttfamily\scriptsize\color{terminaltext}] 
    cp alp_containers_ex3.cpp alp_containers_ex4.cpp 
    \end{lstlisting}
    % Owner: PA
    % Source (ALP_Tutorial.tex - Basic Container I/O, Exercise 4)
\end{frame}
    

    
\begin{frame}[fragile]{3.2. Hands-on: Basic Container I/O}
    \framesubtitle{Container file I/O}
    ALP supports reading sparse matrices from common file formats(e.g. MatrixMarket \texttt{.mtx})
    \begin{itemize}
        \item \textbf{MatrixMarket file parser:}
\begin{lstlisting}[style=code, language=C++, basicstyle=\ttfamily\scriptsize]
#include <graphblas/utils/parser.hpp>
std::string in( "matrix_file.mtx" );
grb::utils::MatrixFileReader< double > parser( in, true );
const auto iterator = parser.begin();
std::cout << "First parsed entry: ( " << iterator.i() << ", " << iterator.j() << " ) = " << iterator.v() << "\n";
\end{lstlisting}
        \begin{itemize}
            \item \textbf{Constructor}: \texttt{filename, consecutive\_vertices (use = \texttt{true} for .mtx)}
            \item \textbf{Sparse iterators}: \texttt{iterator.i()}, \texttt{iterator.j()}, \texttt{iterator.v()}
        \end{itemize}
        \item \textbf{Building/loading matrices from files:}
\begin{lstlisting}[style=code, language=C++, basicstyle=\ttfamily\scriptsize]
grb::RC rc = grb::buildMatrixUnique( A, parser.begin(grb::SEQUENTIAL), 
    parser.end(grb::SEQUENTIAL),grb::SEQUENTIAL);
\end{lstlisting}
        \item \textbf{Iterator types:} \texttt{SEQUENTIAL} (all elements) vs \texttt{PARALLEL} (subset per process)
        \item \textbf{Return codes:} \texttt{grb::RC} (error codes) -> \texttt{grb::SUCCESS} on success
    \end{itemize}
    % Owner: PA
    % Source (ALP_Tutorial.tex - Basic Container I/O)
\end{frame}

\begin{frame}[fragile]{3.2. Hands-on: Basic Container I/O}
\framesubtitle{Exercise 5: File I/O}
\textbf{Exercise 5.} Use the \texttt{MatrixFileReader} and its iterators to build \texttt{A} from \texttt{west0497.mtx}:
\begin{itemize}
    \item Use \texttt{MatrixFileReader} and \texttt{buildMatrixUnique}
    \item Print the number of nonzeroes in \texttt{A} after \texttt{buildMatrixUnique}
    \item Modify the \texttt{main} function to take as the first program argument a path to an .mtx file
    \item Pass that path to the ALP/GraphBLAS program
\end{itemize}
\textbf{Download the west0497 matrix from the SuiteSparse matrix collection:}
\begin{lstlisting}[style=terminal, language=bash, basicstyle=\ttfamily\scriptsize\color{terminaltext}] 
wget "https://suitesparse-collection-website.herokuapp.com/MM/HB/west0497.tar.gz" && tar -xzvf west0497.tar.gz
\end{lstlisting}
\textbf{Run the application with the path \texttt{./west0497/west0497.mtx}. Expected output:}
\begin{lstlisting}[style=terminal, language=bash, basicstyle=\ttfamily\scriptsize\color{terminaltext}]
./a.out ./west0497/west0497.mtx
First parsed entry: ( 495, 496 ) = 0.897354
nonzeroes in A: 1727
\end{lstlisting}
\textbf{Bonus question:} Why is there no \texttt{grb::set(matrix,scalar)} primitive?
% Owner: PA
% Source (ALP_Tutorial.tex - Basic Container I/O, Exercise 5)
\end{frame}

\begin{frame}[fragile]{Hands-on: Copying, Masking, and Standard Matrices (3.3)}
\begin{itemize}
    \item Copy with resize/execute phases
    \item Masks controlling writes
    \item Factory: identity, eye, diag
\end{itemize}
% Owner: PA
% Source (ALP_Tutorial.tex - Copying, Masking, and Standard Matrices):
% \begin{lstlisting}
% grb::Matrix<double> B(497, 497);
% grb::RC rc = grb::set( x, y );
% rc = rc ? rc : grb::set( B, A, grb::RESIZE );
% rc = rc ? rc : grb::set( B, A, grb::EXECUTE );
% \end{lstlisting}
% Mask example:
% \begin{lstlisting}
% grb::RC rc = grb::set( x, y, false );
% \end{lstlisting}
% Factory:
% \begin{lstlisting}
% #include <graphblas/algorithms/matrix_factory.hpp>
% const auto I = grb::algorithms::matrices<double>::identity(n);
% \end{lstlisting}
\end{frame}

\subsection{4) Introduction to primitives (3.4)}
\begin{frame}{Primitives overview (3.4)}
\begin{itemize}
    \item Level-1: foldl/foldr, dot, eWiseAdd/Mul
    \item Level-2: mxv, vxm
    \item Level-3: mxm
\end{itemize}
% Owner: AJ
% Source (ALP_Tutorial.tex - Numerical Linear Algebra):
% Primitives: \texttt{grb::foldl}, \texttt{grb::dot}, \texttt{grb::eWiseAdd}, \texttt{grb::eWiseMul},
% \texttt{grb::mxv}, \texttt{grb::vxm}, \texttt{grb::mxm}.
% \begin{lstlisting}
% auto plusTimes = grb::semirings::plusTimes<double>();
% grb::mxv(y, A, x, plusTimes);
% \end{lstlisting}
\end{frame}

\subsection{5) Exercise 8}
\begin{frame}[fragile]{Exercise 8}
\begin{itemize}
    \item Build small A and x
    \item Compute y=Ax, z=x⊙y, d=xᵀx
    \item Print results
\end{itemize}
% Owner: DJ
% Source (ALP_Tutorial.tex - Exercise 8):
% One example:
% A = [ [0,1,2], [0,3,4], [5,6,0] ], x = [1,2,3]^T
% Expected:
% \begin{lstlisting}[language=bash]
% x = [ 1, 2, 3 ]
% y = A·x = [ 7, 18, 17 ]
% z = x ⊙ y = [ 7, 36, 51 ]
% dot(x,x) = 14
% \end{lstlisting}
\end{frame}

\subsection{6) Closure, transition paths, python mxv examples}
\begin{frame}{Transition paths and Python mxv}
\begin{itemize}
    \item ALP transition paths overview
    \item Re-linking existing codes
    \item Python examples
\end{itemize}
% Owner: DJ & AJ
% Source (ALP_Transition_Path_Tutorial.tex - Intro):
% ALP ... transition path APIs ... drop-in replacements ... re-link your program against ALP's libraries ...
\end{frame}

\subsection{7) Ising Machine, new solvers}
\begin{frame}{Ising Machine, new solvers}
\begin{itemize}
    \item Placeholder for Ising Machine content
    \item New solver directions
\end{itemize}
% Owner: DJ
\end{frame}

% =========================
% Tuesday 11 Nov
% =========================
\section{Tuesday 11 Nov}
\subsection{8) Finish Exercise 8}
\begin{frame}{Finish Exercise 8}
\begin{itemize}
    \item Review results and pitfalls
    \item Alternative builds and descriptors
\end{itemize}
% Owner: DJ
\end{frame}

\subsection{9) Semirings, monoids, operators (add exercise: shortest path)}
\begin{frame}[fragile]{Semirings, monoids, operators}
\begin{itemize}
    \item Defining and using semirings
    \item Built-ins: plusTimes, minPlus, boolean
    \item Exercise: shortest path (min-plus)
\end{itemize}
% Owner: AJ 
% TODO: add exercise "shortest path"
% Source (ALP_Tutorial.tex - Semirings and Algebraic Operations):
% A semiring consists of a pair of operations ...
% \begin{lstlisting}[language=C++]
% using Add = grb::operators::add<double>;
% using AddMonoid = grb::Monoid<Add, grb::identities::zero>;
% using Mul = grb::operators::mul<double>;
% using PlusTimes = grb::Semiring<Mul, AddMonoid>;
% \end{lstlisting}
\end{frame}

\subsection{10) Solvers, transition path, Python API, ABI}
\begin{frame}{Solvers and transition path}
\begin{itemize}
    \item Sparse CG solver API
    \item Preconditioners
    \item ABI and Python API notes
\end{itemize}
% Owner: DJ
% Source (ALP_Transition_Path_Tutorial.tex - API):
% sparse_cg_init / set_preconditioner / solve / destroy — CRS inputs; non-blocking engine, synchronous API.
\end{frame}

\subsection{11) Hands-on: Section 8; CG example; Python example}
\begin{frame}[fragile]{Hands-on: CG example}
\begin{itemize}
    \item Build CRS matrix
    \item Call CG init/solve/destroy
    \item Validate solution
\end{itemize}
% Owner: DJ
% Source (ALP_Transition_Path_Tutorial.tex - Example):
% \begin{lstlisting}[language=C++]
% // A (CRS), b, x; sparse_cg_init_dii(&handle, n, A_vals, A_cols, A_offs);
% // sparse_cg_solve_dii(handle, x, b); sparse_cg_destroy_dii(handle);
% \end{lstlisting}
\end{frame}

\subsection{12) Stretch goal: SPMD and bsp1d backend}
\begin{frame}{SPMD and bsp1d backend (stretch)}
\begin{itemize}
    \item Backend concepts
    \item Launching distributed runs
\end{itemize}
% Owner: AJ  % TODO: install lpf
\end{frame}

\subsection{13) Performance model, high level intro and results}
\begin{frame}{Performance model}
\begin{itemize}
    \item BSP/HBSP overview
    \item Cost components and examples
\end{itemize}
% Owner: PA/
\end{frame}

\subsection{14) SPMD execution, Replica exchange}
\begin{frame}{SPMD execution, Replica exchange}
\begin{itemize}
    \item Concepts and API sketch
    \item Example workflow
\end{itemize}
% Owner: GG
\end{frame}

% =========================
% Wednesday 12 Nov
% =========================
\section{Wednesday 12 Nov}

\subsection{15) WIP overview: dense backend, tensor, stencil, EM simulations}
\begin{frame}{WIP overview}
\begin{itemize}
    \item Dense backend status
    \item Tensor/stencil/EM simulation directions
\end{itemize}
% Owner: DJ
\end{frame}

\subsection{16) Deep technical? Future work (autodiff)}
\begin{frame}{Future work (autodiff)}
\begin{itemize}
    \item Autodiff integration ideas
    \item Open problems and roadmap
\end{itemize}
% Owner: DJ
\end{frame}

\end{document}